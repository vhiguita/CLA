import { Component, Input, Output, EventEmitter, forwardRef, Pipe, NgModule } from '@angular/core';
import { FormBuilder, FormControl, NG_VALUE_ACCESSOR, ReactiveFormsModule } from '@angular/forms';
import 'rxjs/add/operator/debounceTime';
import 'rxjs/add/operator/distinctUntilChanged';
import 'rxjs/add/operator/map';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const intersectionwith = require('lodash.intersectionwith');
const differenceWith = require('lodash.differencewith');
class DualListBoxComponent {
    /**
     * @param {?} fb
     */
    constructor(fb) {
        this.fb = fb;
        // field to use for value of option
        this.valueField = 'id';
        // field to use for displaying option text
        this.textField = 'name';
        // time to debounce search output in ms
        this.debounceTime = 500;
        // show/hide button to move all items between boxes
        this.moveAllButton = true;
        // text displayed over the available items list box
        this.availableText = 'Available items';
        // text displayed over the selected items list box
        this.selectedText = 'Selected items';
        // set placeholder text in available items list box
        this.availableFilterPlaceholder = 'Filter...';
        // set placeholder text in selected items list box
        this.selectedFilterPlaceholder = 'Filter...';
        // event called when item or items from available items(left box) is selected
        this.onAvailableItemSelected = new EventEmitter();
        // event called when item or items from selected items(right box) is selected
        this.onSelectedItemsSelected = new EventEmitter();
        // event called when items are moved between boxes, returns state of both boxes and item moved
        this.onItemsMoved = new EventEmitter();
        // private variables to manage class
        this.searchTermAvailable = '';
        this.searchTermSelected = '';
        this.availableItems = [];
        this.selectedItems = [];
        this.availableListBoxControl = new FormControl();
        this.selectedListBoxControl = new FormControl();
        this.availableSearchInputControl = new FormControl();
        this.selectedSearchInputControl = new FormControl();
        // control value accessors
        this._onChange = (_) => { };
        this._onTouched = () => { };
        this.listBoxForm = this.fb.group({
            availableListBox: this.availableListBoxControl,
            selectedListBox: this.selectedListBoxControl,
            availableSearchInput: this.availableSearchInputControl,
            selectedSearchInput: this.selectedSearchInputControl
        });
    }
    /**
     * @param {?} items
     * @return {?}
     */
    set data(items) {
        this.availableItems = [...(items || []).map((item, index) => ({
                value: item[this.valueField].toString(),
                text: item[this.textField]
            }))];
    }
    ;
    /**
     * @param {?} searchTerm
     * @return {?}
     */
    set availableSearch(searchTerm) {
        this.searchTermAvailable = searchTerm;
        this.availableSearchInputControl.setValue(searchTerm);
    }
    ;
    /**
     * @param {?} searchTerm
     * @return {?}
     */
    set selectedSearch(searchTerm) {
        this.searchTermSelected = searchTerm;
        this.selectedSearchInputControl.setValue(searchTerm);
    }
    ;
    /**
     * @return {?}
     */
    ngOnInit() {
        this.availableListBoxControl
            .valueChanges
            .subscribe((items) => this.onAvailableItemSelected.emit(items));
        this.selectedListBoxControl
            .valueChanges
            .subscribe((items) => this.onSelectedItemsSelected.emit(items));
        this.availableSearchInputControl
            .valueChanges
            .debounceTime(this.debounceTime)
            .distinctUntilChanged()
            .subscribe((search) => this.searchTermAvailable = search);
        this.selectedSearchInputControl
            .valueChanges
            .debounceTime(this.debounceTime)
            .distinctUntilChanged()
            .subscribe((search) => this.searchTermSelected = search);
    }
    /**
     * Move all items from available to selected
     * @return {?}
     */
    moveAllItemsToSelected() {
        if (!this.availableItems.length) {
            return;
        }
        this.selectedItems = [...this.selectedItems, ...this.availableItems];
        this.availableItems = [];
        this.onItemsMoved.emit({
            available: this.availableItems,
            selected: this.selectedItems,
            movedItems: this.availableListBoxControl.value,
            from: 'available',
            to: 'selected'
        });
        this.availableListBoxControl.setValue([]);
        this.writeValue(this.getValues());
    }
    /**
     * Move all items from selected to available
     * @return {?}
     */
    moveAllItemsToAvailable() {
        if (!this.selectedItems.length) {
            return;
        }
        this.availableItems = [...this.availableItems, ...this.selectedItems];
        this.selectedItems = [];
        this.onItemsMoved.emit({
            available: this.availableItems,
            selected: this.selectedItems,
            movedItems: this.selectedListBoxControl.value,
            from: 'selected',
            to: 'available'
        });
        this.selectedListBoxControl.setValue([]);
        this.writeValue([]);
    }
    /**
     * Move marked items from available items to selected items
     * @return {?}
     */
    moveMarkedAvailableItemsToSelected() {
        // first move items to selected
        this.selectedItems = [...this.selectedItems,
            ...intersectionwith(this.availableItems, this.availableListBoxControl.value, (item, value) => item.value === value)];
        // now filter available items to not include marked values
        this.availableItems = [...differenceWith(this.availableItems, this.availableListBoxControl.value, (item, value) => item.value === value)];
        // clear marked available items and emit event
        this.onItemsMoved.emit({
            available: this.availableItems,
            selected: this.selectedItems,
            movedItems: this.availableListBoxControl.value,
            from: 'available',
            to: 'selected'
        });
        this.availableListBoxControl.setValue([]);
        this.availableSearchInputControl.setValue('');
        this.writeValue(this.getValues());
    }
    /**
     * Move marked items from selected items to available items
     * @return {?}
     */
    moveMarkedSelectedItemsToAvailable() {
        // first move items to available
        this.availableItems = [...this.availableItems,
            ...intersectionwith(this.selectedItems, this.selectedListBoxControl.value, (item, value) => item.value === value)];
        // now filter available items to not include marked values
        this.selectedItems = [...differenceWith(this.selectedItems, this.selectedListBoxControl.value, (item, value) => item.value === value)];
        // clear marked available items and emit event
        this.onItemsMoved.emit({
            available: this.availableItems,
            selected: this.selectedItems,
            movedItems: this.selectedListBoxControl.value,
            from: 'selected',
            to: 'available'
        });
        this.selectedListBoxControl.setValue([]);
        this.selectedSearchInputControl.setValue('');
        this.writeValue(this.getValues());
    }
    /**
     * Move single item from available to selected
     * @param {?} item
     * @return {?}
     */
    moveAvailableItemToSelected(item) {
        this.availableItems = this.availableItems.filter((listItem) => listItem.value !== item.value);
        this.selectedItems = [...this.selectedItems, item];
        this.onItemsMoved.emit({
            available: this.availableItems,
            selected: this.selectedItems,
            movedItems: [item.value],
            from: 'available',
            to: 'selected'
        });
        this.availableSearchInputControl.setValue('');
        this.availableListBoxControl.setValue([]);
        this.writeValue(this.getValues());
    }
    /**
     * Move single item from selected to available
     * @param {?} item
     * @return {?}
     */
    moveSelectedItemToAvailable(item) {
        this.selectedItems = this.selectedItems.filter((listItem) => listItem.value !== item.value);
        this.availableItems = [...this.availableItems, item];
        this.onItemsMoved.emit({
            available: this.availableItems,
            selected: this.selectedItems,
            movedItems: [item.value],
            from: 'selected',
            to: 'available'
        });
        this.selectedSearchInputControl.setValue('');
        this.selectedListBoxControl.setValue([]);
        this.writeValue(this.getValues());
    }
    /**
     * Function to pass to ngFor to improve performance, tracks items
     * by the value field
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    trackByValue(index, item) {
        return item[this.valueField];
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (this.selectedItems && value && value.length > 0) {
            this.selectedItems = [...this.selectedItems,
                ...intersectionwith(this.availableItems, value, (item, val) => item.value === val)];
            this.availableItems = [...differenceWith(this.availableItems, value, (item, val) => item.value === val)];
        }
        this._onChange(value);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * Utility method to get values from
     * selected items
     * @return {?}
     */
    getValues() {
        return (this.selectedItems || []).map((item) => item.value);
    }
}
DualListBoxComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng2-dual-list-box',
                template: `<div class="row" [formGroup]="listBoxForm">
    <div class="col-md-5 col-lg-5 col-sm-12">
        <h4 class="text-center vertical-spacing-5">{{availableText}}</h4>
        <input type="text" class="form-control vertical-spacing-5" placeholder="{{availableFilterPlaceholder}}"
               formControlName="availableSearchInput" />
        <select class="form-control list-box" formControlName="availableListBox" multiple>
            <option *ngFor="let item of availableItems | arrayFilter:['text', searchTermAvailable] | arraySort:['text', 'ASC'];trackBy:trackByValue"
                    [value]="item?.value"
                    (dblclick)="moveAvailableItemToSelected(item)">{{item?.text}}</option>
        </select>
    </div>
    <div class="col-md-2 col-lg-2 col-sm-12 center-block text-center">
        <button type="button"
                class="btn btn-default col-md-8 col-md-offset-2 atr top80 sm-spacing"
                *ngIf="moveAllButton" (click)="moveAllItemsToSelected()">
            <span class="glyphicon glyphicon-list"></span>
            <span class="glyphicon glyphicon-chevron-right"></span>
        </button>
        <button type="button"
                class="btn btn-default col-md-8 col-md-offset-2 str vertical-spacing-5 sm-spacing"
                [disabled]="!availableListBoxControl.value?.length"
                (click)="moveMarkedAvailableItemsToSelected()">
            <span class="glyphicon glyphicon-chevron-right"></span>
        </button>
        <button type="button"
                class="btn btn-default col-md-8 col-md-offset-2 stl vertical-spacing-5 sm-spacing"
                [disabled]="!selectedListBoxControl.value?.length"
                (click)="moveMarkedSelectedItemsToAvailable()">
            <span class="glyphicon glyphicon-chevron-left"></span>
        </button>
        <button type="button"
                class="btn btn-default col-md-8 col-md-offset-2 atl bottom10 sm-spacing"
                *ngIf="moveAllButton" (click)="moveAllItemsToAvailable()">
            <span class="glyphicon glyphicon-chevron-left"></span>
            <span class="glyphicon glyphicon-list"></span>
        </button>
    </div>
    <div class="col-md-5 col-lg-5 col-sm-12">
        <h4 class="text-center vertical-spacing-5">{{selectedText}}</h4>
        <input type="text" class="form-control vertical-spacing-5" placeholder="{{selectedFilterPlaceholder}}"
               formControlName="selectedSearchInput" />
        <select class="form-control list-box" formControlName="selectedListBox" multiple>
            <option *ngFor="let item of selectedItems | arrayFilter:['text', searchTermSelected] | arraySort:['text', 'ASC'];trackBy:trackByValue"
                    [value]="item?.value"
                    (dblclick)="moveSelectedItemToAvailable(item)">{{item?.text}}</option>
        </select>
    </div>
</div>`,
                styles: [`.list-box{
    min-height:200px;
    width:100%;
}
.top100{
    margin-top:100px;
}
.top80{
    margin-top:80px;
}
.bottom10{
    margin-bottom:10px;
}
.vertical-spacing-5{
    margin-top:5px;
    margin-bottom:5px;
}
.center-block{
    min-height:50px;
}
@media only screen and (max-width : 768px){
    .sm-spacing{
        margin-top:10px;
        margin-bottom:10px;
    }
}
@media only screen and (min-width : 768px) and (max-width : 992px){
    .sm-spacing{
        margin-top:10px;
        margin-bottom:10px;
    }
}
@media only screen and (max-width : 480px){
    .sm-spacing{
        margin-top:10px;
        margin-bottom:10px;
    }
}`],
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => DualListBoxComponent),
                        multi: true
                    }]
            },] },
];
/** @nocollapse */
DualListBoxComponent.ctorParameters = () => [
    { type: FormBuilder, },
];
DualListBoxComponent.propDecorators = {
    "data": [{ type: Input },],
    "availableSearch": [{ type: Input },],
    "selectedSearch": [{ type: Input },],
    "valueField": [{ type: Input },],
    "textField": [{ type: Input },],
    "title": [{ type: Input },],
    "debounceTime": [{ type: Input },],
    "moveAllButton": [{ type: Input },],
    "availableText": [{ type: Input },],
    "selectedText": [{ type: Input },],
    "availableFilterPlaceholder": [{ type: Input },],
    "selectedFilterPlaceholder": [{ type: Input },],
    "onAvailableItemSelected": [{ type: Output },],
    "onSelectedItemsSelected": [{ type: Output },],
    "onItemsMoved": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const orderby = require('lodash.orderby');
/**
 * Utility class to not hardcode sort directions
 */
class SortOptions {
}
/**
 * Static property to defined ASC and DESC values
 * to avoid hardcoding and repeating
 * replaces string enums
 */
SortOptions.direction = {
    ASC: 'ASC',
    DESC: 'DESC'
};
/**
 * Pipe used to sort arrays by using lodash
 * Takes array and array of 2 strings(parameters), key and direction
 * direction must be either ASC or DESC
 */
class ArraySortPipe {
    /**
     * @param {?} array
     * @param {?} args
     * @return {?}
     */
    transform(array, args) {
        array = array || [];
        if (typeof args === 'undefined' || args.length !== 2) {
            return array;
        }
        const [key, direction] = args;
        if (direction !== SortOptions.direction.ASC && direction !== SortOptions.direction.DESC) {
            return array;
        }
        // if there is no key we assume item is of string type
        return orderby(array, (item) => item.hasOwnProperty(key) ? item[key] : item, direction.toLowerCase());
    }
}
ArraySortPipe.decorators = [
    { type: Pipe, args: [{
                name: 'arraySort'
            },] },
];
/** @nocollapse */
ArraySortPipe.ctorParameters = () => [];
/**
 * Pipe used to filter array, takes input array and
 * array of 2 arguments, key of object and search term
 * if key does not exist, pipe assumes the item is string
 */
class ArrayFilterPipe {
    /**
     * @param {?} array
     * @param {?} args
     * @return {?}
     */
    transform(array, args) {
        array = array || [];
        if (typeof args === 'undefined' || args.length !== 2) {
            return array;
        }
        const [key, searchTerm] = args;
        if (searchTerm.trim() === '') {
            return array;
        }
        return array.filter((item) => item[key].toString().toLowerCase().search(searchTerm.toLowerCase().trim()) >= 0);
    }
}
ArrayFilterPipe.decorators = [
    { type: Pipe, args: [{
                name: 'arrayFilter'
            },] },
];
/** @nocollapse */
ArrayFilterPipe.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DualListBoxModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: DualListBoxModule
        };
    }
}
DualListBoxModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ReactiveFormsModule
                ],
                declarations: [
                    ArraySortPipe,
                    ArrayFilterPipe,
                    DualListBoxComponent
                ],
                exports: [
                    ArraySortPipe,
                    ArrayFilterPipe,
                    DualListBoxComponent
                ]
            },] },
];
/** @nocollapse */
DualListBoxModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { DualListBoxModule, DualListBoxComponent, SortOptions, ArraySortPipe, ArrayFilterPipe };
//# sourceMappingURL=ng2-dual-list-box.js.map
